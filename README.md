# cas-jvm

## java指令
    class解释称机器指令
    javap -v xxx.class | class -> 可读文件
    javac xxx.java     | java  -> class

## 编译器和JIT的区别
    编译器: 这个东西第一代jvm就有了，他可以解释字节码文件，但是效率不高，因为每次执行都会从头开始编译执行代码，消耗资源
    JIT: 这个东西呢就是解决上面编译器的难处，他提供了一个缓存，能够存储编译过后的机器码指令，这样就不用每次执行代码都去编译
         一次，他也只会缓存热点执行代码，避免缓存消耗也是对的。

## 历史
    现在市场常用的几个版本：HotSpot, JrRockit, J9

## JVM判断两个对象是否为一个对象
    1、包名和类型完全一致
    2、类加载器完全一致
    
## 栈帧包含哪些组件
    1、局部变量表
        局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不回被回收
    
    2、操作数栈
                
    3、动态链接
        保存方法的引用信息，在常量池中
    4、方法返回地址
        4.1、方法的调用：普通调用指令 
            1、invokestatic 调用静态方法，解析阶段确定唯一方法版本
            2、invokespecial 调用<init>方法、私有及弗雷方法，解析阶段确定唯一方法版本
            3、invokevirtual 调用所有虚方法
            4、invokeinterface 调用接口方法
        4.2、动态调用指令
            5、invokedynamic 动态解析出需要调用的方法，然后执行
        前四条指令固化虚拟机内部，方法的调用执行不可人为干扰，而invokedynamic指令则支持
        由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，
        其余的(final修饰的除外)称为虚方法。
        4.3、非虚方法
            -如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。
             这样的方法称为"非虚方法"
            -静态方法、私有方法、final方法、实例构造器、父类方法都是非 
        4.4、调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址
            * 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。
            
    5、一些附加信息
        对程序调试提供的信息

## 本地方法
    一个Native method就是一个java调用非java代码的接口，该方法是非java语言实现。
    

## 堆
    一个java程序对应一个进程
    一个进程对应一个jvm实例
    一个jvm实例中只有一个运行时数据区
    一个运行时数据区只有一个方法区和堆
    一个进程中的多个线程需要共享同一个方法区，堆空间
    每一个线程拥有独立的一套程序计数器，本地方法栈，虚拟机栈

    默认堆空间大小
        初始内存大小：物理电脑内存大小 / 64
        最大内存大小：物理电脑内存大小 / 4

    查看堆空间使用情况
    1、 jps -> jstat -gc 进程号 
    2、 -XX:+printGCDetails


## 代码优化之栈上分配
    JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。
    分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。
    
    常见的栈上分配的场景
    在逃逸分析中，已经说明了。分别是给成员变量赋值，方法返回值，实例引用传递。

## 锁消除
    1、线程同步的代价是相当高的，同步的后果是降低并发性和性能
    2、在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能被一个
    线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消这部分代码的
    同步。这样就能大大提高并发性和性能。这样取消同步的过程就叫同步省略，也叫锁消除。

## 方法区
    如何设置方法区的大小
    1、方法区的大小不必是固定的，jvm可以根据应用动态调整
    
    jdk8及以后：
        元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替代上述原有的两个参数。
        默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize 的值是-1，即没有限制
        我们一般推荐将初始默认值设置为一个较高的值
        
        与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出
        异常OutOfMemoryError:Metaspace
        
        -XX:MetaspaceSize: 设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的
        -XX:MetaspaceSize值位21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载
        没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间 。
        如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。
        
        如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以
        观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。
    

## 参数
    -Xss258k == 虚拟机栈大小
    -Xms10m  == java堆初始大小
    -Xmx10m  == java堆最大大小
    -XX:NewRatio == 设置新生代与老年代的比例。默认值是2
    -XX:SurvicorRatio == 设置新生代中Eden区与Survivor区的比例,默认值是8
    -XX:-UseAdaptiveSizePolicy == 关闭自适应的内存分配策略
    -Xmn == 设置新生代的空间大小（优先级高,一般不设置）
    -XX:MaxTenuringThreshold == 最大新生代年龄晋升阀值
    -XX:+PrintGCDetails == 打印详细的GC处理日志
    -XX:UseTLAB == 设置是否开启TLAB空间（默认开启）
    -XX:TLABWasteTargetPercent == 设置TLAB空间所占Eden空间的百分比大小
    -XX:+PrintFlagsInitial == 查看所有的参数的默认初始值
    -XX:+PrintFlagsFinal == 查看所有的参数的最终值
    -XX:HandlePromotionFailure == 是否设置空间分配担保
    -XX:+DoEscapeAnalysis == 显式开启逃逸分析
    -XX:+PrintEscapeAnalysis == 查看逃逸分析的筛选结果
    -XX:+EliminateAllocations == 开启标量替换（默认打开）
    -XX:MetaspaceSize == 指定元空间大小
    -XX:MaxMetaspaceSize == 最大元空间大小
    
    








